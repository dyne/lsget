<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ðŸ“‚ lsget</title>

    <!-- Helpers FIRST so they're available before Datastar evaluates attributes -->
    <script>
      // Convert ANSI color codes to HTML with CSS styling
      window.ansiToHtml = function (s) {
        const colors = {
          // Reset
          "\x1b[0m": "</span>",

          // Text colors using Catppuccin Frappe palette
          "\x1b[31m": '<span style="color: #e78284">', // Red (archives)
          "\x1b[32m": '<span style="color: #a6d189">', // Green (executables, audio, scripts)
          "\x1b[33m": '<span style="color: #e5c890">', // Yellow (source code, special files)
          "\x1b[34m": '<span style="color: #8caaee">', // Blue (directories)
          "\x1b[35m": '<span style="color: #f4b8e4">', // Magenta (images)
          "\x1b[36m": '<span style="color: #81c8be">', // Cyan (symlinks)
          "\x1b[37m": '<span style="color: #c6d0f5">', // White (documents)

          // Bright text colors using Catppuccin Frappe palette
          "\x1b[90m": '<span style="color: #737994">', // Bright Black (log/temp files)
          "\x1b[92m": '<span style="color: #a6d189">', // Bright Green (video files)
          "\x1b[93m": '<span style="color: #e5c890">', // Bright Yellow (web files)
          "\x1b[96m": '<span style="color: #99d1db">', // Bright Cyan (database files)

          // Text attributes (only the ones actually used)
          "\x1b[1m": '<span style="font-weight: 400">', // Bold (directories)
        };

        let result = String(s);

        // Escape HTML characters that aren't part of our spans
        result = result.replace(/[&<>"']/g, function (m) {
          return {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
          }[m];
        });

        // Replace ANSI codes with HTML spans
        for (const [code, html] of Object.entries(colors)) {
          result = result.replace(
            new RegExp(code.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
            html,
          );
        }

        return result;
      };

      // Safe HTML escaping for any server/user text we inject via innerHTML (fallback)
      window.escapeHTML = function (s) {
        return String(s).replace(/[&<>"']/g, function (m) {
          return {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
          }[m];
        });
      };
      // For Tab completion
      window.longestCommonPrefix = function (arr) {
        if (!arr || !arr.length) return "";
        let p = arr[0];
        for (let i = 1; i < arr.length; i++) {
          const s = arr[i];
          let j = 0;
          while (j < p.length && j < s.length && p[j] === s[j]) j++;
          p = p.slice(0, j);
          if (!p) break;
        }
        return p;
      };
      // Document rendering functions
      window.renderDocument = function (content, docType) {
        if (!content) return "";

        switch (docType) {
          case "markdown":
            return marked.parse(content);
          case "rst":
            // Basic RST to HTML conversion
            return renderRST(content);
          case "nfo":
            // NFO files should preserve formatting and use monospace
            return `<pre class="nfo-content">${escapeHTML(content)}</pre>`;
          case "text":
            // Plain text with basic formatting
            return `<pre class="text-content">${escapeHTML(content)}</pre>`;
          default:
            return `<pre class="text-content">${escapeHTML(content)}</pre>`;
        }
      };

      // Basic RST to HTML converter
      window.renderRST = function (content) {
        let html = escapeHTML(content);

        // Headers
        html = html.replace(/^(.+)\n=+$/gm, "<h1>$1</h1>");
        html = html.replace(/^(.+)\n-+$/gm, "<h2>$1</h2>");
        html = html.replace(/^(.+)\n\^+$/gm, "<h3>$1</h3>");
        html = html.replace(/^(.+)\n"+$/gm, "<h4>$1</h4>");

        // Bold and italic
        html = html.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        html = html.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        // Code blocks
        html = html.replace(/::$/gm, "");
        html = html.replace(/^    (.+)$/gm, "<code>$1</code>");

        // Links
        html = html.replace(
          /`([^`]+) &lt;([^&]+)&gt;`_/g,
          '<a href="$2">$1</a>',
        );

        // Line breaks
        html = html.replace(/\n\n/g, "</p><p>");
        html = "<p>" + html + "</p>";

        // Clean up empty paragraphs
        html = html.replace(/<p>\s*<\/p>/g, "");

        return html;
      };

      // Config pulled from server (cat size limit)
      window.CAT_MAX = 262144; // default, will be overwritten by /api/config
      window.DOC_TYPE = "markdown"; // default document type
      fetch("/api/config")
        .then((r) => r.json())
        .then((cfg) => {
          if (cfg && typeof cfg.catMax === "number")
            window.CAT_MAX = cfg.catMax;
          if (cfg && typeof cfg.readme === "string") {
            window.INIT_README = cfg.readme;
            window.DOC_TYPE = cfg.docType || "markdown";
            window.dispatchEvent(
              new CustomEvent("initreadme", {
                detail: { content: cfg.readme, type: cfg.docType },
              }),
            );
          }
        })
        .catch(() => {});

      // Sync current working directory on page load
      window.addEventListener("DOMContentLoaded", () => {
        fetch("/api/exec", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: "pwd" })
        })
        .then(r => r.json())
        .then(res => {
          if (res && res.cwd) {
            // Update the datastar signals
            window.dispatchEvent(new CustomEvent("syncCwd", {
              detail: { cwd: res.cwd }
            }));
          }
        })
        .catch(() => {});
      });
      // Start a download by programmatically clicking an <a>
      window.startDownload = function (href) {
        try {
          const a = document.createElement("a");
          a.href = href;
          a.download = "";
          document.body.appendChild(a);
          a.click();
          a.remove();
        } catch {}
      };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Datastar: Alpine-like data-* reactivity -->
    <script
      type="module"
      src="https://cdn.jsdelivr.net/gh/starfederation/datastar@main/bundles/datastar.js"
    ></script>

    <style>
      :root {
        /* Catppuccin Frappe theme for terminal */
        --ctp-frappe-rosewater: #f2d5cf;
        --ctp-frappe-flamingo: #eebebe;
        --ctp-frappe-pink: #f4b8e4;
        --ctp-frappe-mauve: #ca9ee6;
        --ctp-frappe-red: #e78284;
        --ctp-frappe-maroon: #ea999c;
        --ctp-frappe-peach: #ef9f76;
        --ctp-frappe-yellow: #e5c890;
        --ctp-frappe-green: #a6d189;
        --ctp-frappe-teal: #81c8be;
        --ctp-frappe-sky: #99d1db;
        --ctp-frappe-sapphire: #85c1dc;
        --ctp-frappe-blue: #8caaee;
        --ctp-frappe-lavender: #babbf1;
        --ctp-frappe-text: #c6d0f5;
        --ctp-frappe-subtext1: #b5bfe2;
        --ctp-frappe-subtext0: #a5adce;
        --ctp-frappe-overlay2: #949cbb;
        --ctp-frappe-overlay1: #838ba7;
        --ctp-frappe-overlay0: #737994;
        --ctp-frappe-surface2: #626880;
        --ctp-frappe-surface1: #51576d;
        --ctp-frappe-surface0: #414559;
        --ctp-frappe-base: #303446;
        --ctp-frappe-mantle: #292c3c;
        --ctp-frappe-crust: #232634;

        /* Terminal colors using Frappe */
        --olivetti: var(--ctp-frappe-green);
        --term-bg: var(--ctp-frappe-base);
        --term-text: var(--ctp-frappe-text);
        --term-border: var(--ctp-frappe-surface2);

        /* Catppuccin Latte theme for README */
        --ctp-latte-rosewater: #dc8a78;
        --ctp-latte-flamingo: #dd7878;
        --ctp-latte-pink: #ea76cb;
        --ctp-latte-mauve: #8839ef;
        --ctp-latte-red: #d20f39;
        --ctp-latte-maroon: #e64553;
        --ctp-latte-peach: #fe640b;
        --ctp-latte-yellow: #df8e1d;
        --ctp-latte-green: #40a02b;
        --ctp-latte-teal: #179299;
        --ctp-latte-sky: #04a5e5;
        --ctp-latte-sapphire: #209fb5;
        --ctp-latte-blue: #1e66f5;
        --ctp-latte-lavender: #7287fd;
        --ctp-latte-text: #4c4f69;
        --ctp-latte-subtext1: #5c5f77;
        --ctp-latte-subtext0: #6c6f85;
        --ctp-latte-overlay2: #7c7f93;
        --ctp-latte-overlay1: #8c8fa1;
        --ctp-latte-overlay0: #9ca0b0;
        --ctp-latte-surface2: #acb0be;
        --ctp-latte-surface1: #bcc0cc;
        --ctp-latte-surface0: #ccd0da;
        --ctp-latte-base: #eff1f5;
        --ctp-latte-mantle: #e6e9ef;
        --ctp-latte-crust: #dce0e8;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--term-bg);
        color: var(--term-text);
        font:
          16px/1.5 ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "DejaVu Sans Mono",
          monospace;
      }
      .layout {
        display: flex;
        height: 100%;
        position: relative;
      }
      .terminal {
        height: 100%;
        padding: 1rem;
        outline: none;
        display: flex;
        flex: 2;
        min-width: 0;
      }
      .screen {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        flex: 1;
        overflow: auto;
        text-shadow:
          0 0 2px currentColor,
          0 0 6px currentColor;
      }
      .readme {
        flex: 1;
        padding: 1rem;
        overflow: auto;
        border-left: 1px solid var(--term-border);
        background: var(--ctp-latte-base);
        color: var(--ctp-latte-text);
        min-width: 0;
      }

      /* Mobile toggle button */
      .mobile-toggle {
        display: none;
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        z-index: 1000;
        background: var(--ctp-frappe-blue);
        color: var(--ctp-frappe-base);
        border: none;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        font-size: 1.5rem;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s;
      }
      .mobile-toggle:active {
        transform: scale(0.95);
      }

      /* Responsive styles */
      @media (max-width: 768px) {
        body {
          font-size: 14px;
        }
        .layout {
          flex-direction: column;
        }
        .terminal {
          flex: 1;
          padding: 0.75rem;
        }
        .readme {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 999;
          border-left: none;
          border-top: 4px solid var(--ctp-frappe-blue);
          transform: translateY(100%);
          transition: transform 0.3s ease;
        }
        .readme.show {
          transform: translateY(0);
        }
        .mobile-toggle {
          display: block;
        }
        .screen {
          text-shadow: none;
        }
      }

      @media (max-width: 480px) {
        body {
          font-size: 12px;
        }
        .terminal {
          padding: 0.5rem;
        }
        .readme {
          padding: 0.75rem;
        }
        .mobile-toggle {
          width: 2.5rem;
          height: 2.5rem;
          font-size: 1.25rem;
        }
      }

      /* Tablet styles */
      @media (min-width: 769px) and (max-width: 1024px) {
        .terminal {
          flex: 1.5;
        }
        .readme {
          flex: 1;
        }
      }

      /* Large desktop */
      @media (min-width: 1440px) {
        body {
          font-size: 18px;
        }
        .layout {
          max-width: 1920px;
          margin: 0 auto;
        }
      }

      /* Catppuccin Latte styling for documentation content */
      .readme h1,
      .readme h2,
      .readme h3,
      .readme h4,
      .readme h5,
      .readme h6 {
        color: var(--ctp-latte-blue);
        border-bottom: 2px solid var(--ctp-latte-surface1);
        padding-bottom: 0.3em;
      }

      /* Styling for different document types */
      .readme .nfo-content {
        font-family: "Courier New", "DejaVu Sans Mono", monospace;
        font-size: 12px;
        line-height: 1.2;
        color: var(--ctp-latte-text);
        background: var(--ctp-latte-mantle);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        white-space: pre;
        border-left: 4px solid var(--ctp-latte-mauve);
      }

      .readme .text-content {
        color: var(--ctp-latte-text);
        background: var(--ctp-latte-surface0);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        white-space: pre-wrap;
        border-left: 4px solid var(--ctp-latte-green);
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "DejaVu Sans Mono", monospace;
      }

      .readme h1 {
        color: var(--ctp-latte-red);
      }
      .readme h2 {
        color: var(--ctp-latte-peach);
      }
      .readme h3 {
        color: var(--ctp-latte-yellow);
      }
      .readme h4 {
        color: var(--ctp-latte-green);
      }
      .readme h5 {
        color: var(--ctp-latte-teal);
      }
      .readme h6 {
        color: var(--ctp-latte-blue);
      }

      .readme p {
        color: var(--ctp-latte-text);
        line-height: 1.6;
      }

      .readme a {
        color: var(--ctp-latte-sapphire);
        text-decoration: none;
      }

      .readme a:hover {
        color: var(--ctp-latte-blue);
        text-decoration: underline;
      }

      .readme code {
        background: var(--ctp-latte-surface0);
        color: var(--ctp-latte-red);
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 0.9em;
      }

      .readme pre {
        background: var(--ctp-latte-mantle);
        color: var(--ctp-latte-text);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        border-left: 4px solid var(--ctp-latte-blue);
      }

      .readme pre code {
        background: transparent;
        color: inherit;
        padding: 0;
      }

      .readme blockquote {
        border-left: 4px solid var(--ctp-latte-mauve);
        margin: 0;
        padding-left: 1em;
        color: var(--ctp-latte-subtext0);
        font-style: italic;
      }

      .readme ul,
      .readme ol {
        color: var(--ctp-latte-text);
      }

      .readme li {
        margin: 0.2em 0;
      }

      .readme strong {
        color: var(--ctp-latte-red);
        font-weight: bold;
      }

      .readme em {
        color: var(--ctp-latte-mauve);
        font-style: italic;
      }

      .readme table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
      }

      .readme th,
      .readme td {
        border: 1px solid var(--ctp-latte-surface1);
        padding: 0.5em;
        text-align: left;
      }

      .readme th {
        background: var(--ctp-latte-surface0);
        color: var(--ctp-latte-blue);
        font-weight: bold;
      }

      .readme hr {
        border: none;
        height: 2px;
        background: var(--ctp-latte-surface1);
        margin: 2em 0;
      }

      /* Document type indicator */
      .readme::before {
        content: attr(data-doc-type);
        display: block;
        font-size: 0.8em;
        color: var(--ctp-latte-subtext0);
        text-transform: uppercase;
        margin-bottom: 0.5em;
        padding: 0.2em 0.5em;
        background: var(--ctp-latte-surface1);
        border-radius: 3px;
        width: fit-content;
      }
      .line {
        display: block;
      }
      .ps1 {
        color: var(--ctp-frappe-green);
      }
      .input {
        color: var(--ctp-frappe-text);
      }
      .out {
        color: var(--ctp-frappe-text);
      }
      .out {
        opacity: 0.85;
        line-height: 1.18;
      }
      .cursor {
        display: inline-block;
        width: 0.6em;
      }
      .terminal:focus-within .cursor {
        animation: blink 1s steps(1, end) infinite;
      }
      .terminal:not(:focus-within) .cursor {
        animation: none;
        opacity: 0.5;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }
      ::selection {
        background: var(--ctp-frappe-mauve);
        color: var(--ctp-frappe-base);
      }
      .ghost {
        position: fixed;
        left: -10000px;
        top: auto;
        width: 1px;
        height: 1px;
        opacity: 0;
        border: 0;
        padding: 0;
        background: transparent;
        color: transparent;
      }
    </style>
  </head>
  <body>
    <div
      class="layout"
      data-signals='{ "ps1": "guest@browser:/$ ", "cwd": "/", "current": "", "buffer": "{{HELP_MESSAGE}}", "history": [], "histIndex": 0, "readme": "", "showReadme": false }'
    >
      <div
        class="terminal"
        data-on-load="
            el.querySelector('#ghost').focus();
            const init = window.INIT_README || '';
            $readme = init ? renderDocument(init, window.DOC_TYPE) : '';
            window.addEventListener('initreadme', (e) => {
              if (e.detail && typeof e.detail === 'object') {
                $readme = e.detail.content ? renderDocument(e.detail.content, e.detail.type || 'markdown') : '';
              } else {
                // Backward compatibility
                $readme = e.detail ? renderDocument(e.detail, 'markdown') : '';
              }
            });
            window.addEventListener('syncCwd', (e) => {
              if (e.detail && e.detail.cwd) {
                $cwd = e.detail.cwd;
                $ps1 = `guest@browser:${e.detail.cwd}$ `;
              }
            });
          "
        data-on-click="el.querySelector('#ghost').focus()"
        data-on-keydown="
         const k=evt.key;
         if (k==='Enter') {
           const cmd = $current;
           $buffer += `<div class='line'><span class='ps1'>${$ps1}</span>${escapeHTML(cmd)}</div>`;
           if (cmd) { $history.push(cmd); }
           $histIndex = $history.length;
           $current = '';
           const sc = el.querySelector('.screen');
           requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });

           fetch('/api/exec', {
             method: 'POST', headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ input: cmd })
           })
           .then(r => r.ok ? r.json() : Promise.reject(new Error(`HTTP ${r.status}`)))
             .then((res) => {
               const { output, download, cwd } = res || {};
             if (typeof output === 'string' && output.length) {
               $buffer += `<div class='line out'>${ansiToHtml(output)}</div>`;
             }
             if (download) { startDownload(download); }
               if (cwd !== undefined) {
                  $cwd = cwd;
                  $ps1 = `guest@browser:${cwd}$ `;
               }
               if (res && Object.prototype.hasOwnProperty.call(res, 'readme')) {
                 $readme = res.readme ? renderDocument(res.readme, res.docType || 'markdown') : '';
               }
               requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
           })
           .catch(err => {
             $buffer += `<div class='line out'>error: ${escapeHTML(String(err))}</div>`;
             requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
           });

           evt.preventDefault();
         } else if (k==='Backspace') {
           if ($current.length) { $current = $current.slice(0,-1); }
           evt.preventDefault();
         } else if (k==='Tab') {
           const m = $current.match(/^\s*(\S+)(?:\s+(.*))?$/);
           const cmd = m ? m[1] : '';
           let arg = m && m[2] !== undefined ? m[2] : '';
           const isCd = (cmd === 'cd');
           const isCat = (cmd === 'cat');
           const isGet = (cmd === 'get' || cmd === 'rget' || cmd === 'download');
           if (isCd || isCat || isGet) {
             const body = { path: arg || '', dirsOnly: false, filesOnly: false, maxSize: 0, textOnly: false };
             if (isCd) { body.dirsOnly = true; }
             if (isCat) { body.filesOnly = true; body.textOnly = true; body.maxSize = (window.CAT_MAX||0); }
             if (isGet) { body.filesOnly = true; }
             fetch('/api/complete', {
               method: 'POST', headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify(body)
             })
             .then(r => r.ok ? r.json() : Promise.reject(new Error(`HTTP ${r.status}`)))
             .then(({ items }) => {
               if (!Array.isArray(items) || items.length === 0) return;
               const slash = (arg||'').lastIndexOf('/');
               const dirPart  = slash >= 0 ? arg.slice(0, slash+1) : '';
               const basePart = slash >= 0 ? arg.slice(slash+1) : (arg||'');
               const names = items.map(it => it.name);
               const lcp = longestCommonPrefix(names);
               if (lcp && lcp !== basePart) {
                 $current = cmd + ' ' + (dirPart + lcp);
               } else if (items.length === 1) {
                 const one = items[0];
                 $current = cmd + ' ' + (dirPart + one.name + (one.dir ? '/' : ''));
               } else {
                 const list = items.map(it => it.name + (it.dir ? '/' : '')).join('  ');
                 $buffer += `<div class='line out'>${ansiToHtml(list)}</div>`;
                 const sc = el.querySelector('.screen'); requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
               }
             })
             .catch(()=>{});
             evt.preventDefault();
           } else {
             $current += '    ';
             evt.preventDefault();
           }
         } else if (k==='ArrowUp') {
           if ($histIndex>0) { $histIndex--; $current = $history[$histIndex] ?? ''; }
           evt.preventDefault();
         } else if (k==='ArrowDown') {
           if ($histIndex < $history.length) { $histIndex++; $current = $history[$histIndex] ?? ''; }
           evt.preventDefault();
         }
       "
      >
        <input
          id="ghost"
          class="ghost"
          type="text"
          inputmode="text"
          autocomplete="off"
          autocapitalize="off"
          spellcheck="false"
          autofocus
          aria-label="Hidden terminal input"
          data-on-input="$current += evt.target.value; evt.target.value='';"
        />

        <pre
          id="screen"
          class="screen"
          data-ref-screen
          data-effect="el.innerHTML = $buffer + `<div class='line'><span class='ps1'>${$ps1}</span><span class='input'></span><span class='cursor'>â–ˆ</span></div>`; el.querySelector('.input').textContent = $current;"
        ></pre>
      </div>
      <div
        id="readme"
        class="readme"
        data-class-show="$showReadme"
        data-effect="el.innerHTML = $readme"
      ></div>
      <button
        class="mobile-toggle"
        data-on-click="$showReadme = !$showReadme"
        data-text="$showReadme ? 'âœ•' : 'ðŸ“–'"
        aria-label="Toggle README"
      ></button>
    </div>
  </body>
</html>

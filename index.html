<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ðŸ“‚ lsget</title>

    <!-- No-JS fallback: redirect to plain HTML version -->
    <noscript>
      <meta http-equiv="refresh" content="0; url=?nojs=1" />
    </noscript>

    <!-- Helpers FIRST so they're available before Datastar evaluates attributes -->
    <script>
      // Convert ANSI color codes to HTML with CSS styling
      window.ansiToHtml = function (s) {
        const colors = {
          // Reset
          "\x1b[0m": "</span>",

          // Text colors using Catppuccin Frappe palette
          "\x1b[31m": '<span style="color: #e78284">', // Red (archives)
          "\x1b[32m": '<span style="color: #a6d189">', // Green (executables, audio, scripts)
          "\x1b[33m": '<span style="color: #e5c890">', // Yellow (source code, special files)
          "\x1b[34m": '<span style="color: #8caaee">', // Blue (directories)
          "\x1b[35m": '<span style="color: #f4b8e4">', // Magenta (images)
          "\x1b[36m": '<span style="color: #81c8be">', // Cyan (symlinks)
          "\x1b[37m": '<span style="color: #c6d0f5">', // White (documents)

          // Bright text colors using Catppuccin Frappe palette
          "\x1b[90m": '<span style="color: #737994">', // Bright Black (log/temp files)
          "\x1b[92m": '<span style="color: #a6d189">', // Bright Green (video files)
          "\x1b[93m": '<span style="color: #e5c890">', // Bright Yellow (web files)
          "\x1b[96m": '<span style="color: #99d1db">', // Bright Cyan (database files)

          // Text attributes (only the ones actually used)
          "\x1b[1m": '<span style="font-weight: 400">', // Bold (directories)
        };

        let result = String(s);

        // Escape HTML characters that aren't part of our spans
        result = result.replace(/[&<>"']/g, function (m) {
          return {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
          }[m];
        });

        // Replace ANSI codes with HTML spans
        for (const [code, html] of Object.entries(colors)) {
          result = result.replace(
            new RegExp(code.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
            html,
          );
        }

        return result;
      };

      // Make filenames and directories clickable
      window.makeClickable = function (html) {
        return html.replace(
          /<span style="[^"]*color: #[0-9a-f]{6}[^"]*">(?:<span[^>]*>)?([^<]+?)(?:<\/span>)?<\/span>/gi,
          function (match, filename) {
            if (match.includes('clickable-file')) return match;

            const name = filename.trim();
            if (!name) return match;

            const isDir = name.endsWith('/');
            const cleanName = isDir ? name.slice(0, -1) : name;
            const cmd = isDir ? 'cd' : 'cat';
            const escaped = cleanName.replace(/"/g, '&quot;').replace(/'/g, '&#039;');

            return match.replace(/^<span/, `<span class="clickable-file" data-cmd="${cmd}" data-file="${escaped}"`);
          }
        );
      };

      // Safe HTML escaping for any server/user text we inject via innerHTML (fallback)
      window.escapeHTML = function (s) {
        return String(s).replace(/[&<>"']/g, function (m) {
          return {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
          }[m];
        });
      };
      // For Tab completion
      window.longestCommonPrefix = function (arr) {
        if (!arr || !arr.length) return "";
        let p = arr[0];
        for (let i = 1; i < arr.length; i++) {
          const s = arr[i];
          let j = 0;
          while (j < p.length && j < s.length && p[j] === s[j]) j++;
          p = p.slice(0, j);
          if (!p) break;
        }
        return p;
      };
      // Document rendering functions
      window.renderDocument = function (content, docType) {
        if (!content) return "";

        switch (docType) {
          case "markdown":
            return marked.parse(content);
          case "rst":
            // Basic RST to HTML conversion
            return renderRST(content);
          case "nfo":
            // NFO files should preserve formatting and use monospace
            return `<pre class="nfo-content">${escapeHTML(content)}</pre>`;
          case "text":
            // Plain text with basic formatting
            return `<pre class="text-content">${escapeHTML(content)}</pre>`;
          default:
            return `<pre class="text-content">${escapeHTML(content)}</pre>`;
        }
      };

      // Basic RST to HTML converter
      window.renderRST = function (content) {
        let html = escapeHTML(content);

        // Headers
        html = html.replace(/^(.+)\n=+$/gm, "<h1>$1</h1>");
        html = html.replace(/^(.+)\n-+$/gm, "<h2>$1</h2>");
        html = html.replace(/^(.+)\n\^+$/gm, "<h3>$1</h3>");
        html = html.replace(/^(.+)\n"+$/gm, "<h4>$1</h4>");

        // Bold and italic
        html = html.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        html = html.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        // Code blocks
        html = html.replace(/::$/gm, "");
        html = html.replace(/^    (.+)$/gm, "<code>$1</code>");

        // Links
        html = html.replace(
          /`([^`]+) &lt;([^&]+)&gt;`_/g,
          '<a href="$2">$1</a>',
        );

        // Line breaks
        html = html.replace(/\n\n/g, "</p><p>");
        html = "<p>" + html + "</p>";

        // Clean up empty paragraphs
        html = html.replace(/<p>\s*<\/p>/g, "");

        return html;
      };

      // Click handler for file/directory navigation
      document.addEventListener('DOMContentLoaded', function() {
        const executeCommand = (command) => {
          const ghost = document.getElementById('ghost');
          if (!ghost) return;

          ghost.value = command;
          ghost.dispatchEvent(new Event('input', { bubbles: true }));
          ghost.value = '';
          ghost.dispatchEvent(new KeyboardEvent('keydown', {
            key: 'Enter', bubbles: true, cancelable: true
          }));
        };

        document.addEventListener('click', function(evt) {
          let target = evt.target;
          while (target && target !== document) {
            if (target.classList && target.classList.contains('clickable-file')) {
              const cmd = target.getAttribute('data-cmd');
              const file = target.getAttribute('data-file');

              if (cmd && file) {
                if (cmd === 'cd') {
                  executeCommand('cd ' + file);
                  setTimeout(() => executeCommand('ls'), 200);
                } else {
                  executeCommand(cmd + ' ' + file);
                }
                evt.preventDefault();
                evt.stopPropagation();
                return;
              }
            }
            target = target.parentElement;
          }
        });
      });

      // Config pulled from server (cat size limit)
      window.CAT_MAX = 262144; // default, will be overwritten by /api/config
      window.DOC_TYPE = "markdown"; // default document type
      fetch("/api/config")
        .then((r) => r.json())
        .then((cfg) => {
          if (cfg && typeof cfg.catMax === "number")
            window.CAT_MAX = cfg.catMax;
          if (cfg && typeof cfg.readme === "string") {
            window.INIT_README = cfg.readme;
            window.DOC_TYPE = cfg.docType || "markdown";
            window.dispatchEvent(
              new CustomEvent("initreadme", {
                detail: { content: cfg.readme, type: cfg.docType },
              }),
            );
          }
        })
        .catch(() => {});

      // Sync current working directory on page load
      window.addEventListener("DOMContentLoaded", () => {
        fetch("/api/exec", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: "pwd" }),
        })
          .then((r) => r.json())
          .then((res) => {
            if (res && res.cwd) {
              // Update the datastar signals
              window.dispatchEvent(
                new CustomEvent("syncCwd", {
                  detail: { cwd: res.cwd },
                }),
              );
            }
          })
          .catch(() => {});
      });
      // Start a download by programmatically clicking an <a>
      window.startDownload = function (href) {
        try {
          const a = document.createElement("a");
          a.href = href;
          a.download = "";
          document.body.appendChild(a);
          a.click();
          a.remove();
        } catch {}
      };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Datastar: Alpine-like data-* reactivity -->
    <script
      type="module"
      src="https://cdn.jsdelivr.net/gh/starfederation/datastar@main/bundles/datastar.js"
    ></script>

    <style>
      :root {
        /* Catppuccin Frappe theme for terminal */
        --ctp-frappe-rosewater: #f2d5cf;
        --ctp-frappe-flamingo: #eebebe;
        --ctp-frappe-pink: #f4b8e4;
        --ctp-frappe-mauve: #ca9ee6;
        --ctp-frappe-red: #e78284;
        --ctp-frappe-maroon: #ea999c;
        --ctp-frappe-peach: #ef9f76;
        --ctp-frappe-yellow: #e5c890;
        --ctp-frappe-green: #a6d189;
        --ctp-frappe-teal: #81c8be;
        --ctp-frappe-sky: #99d1db;
        --ctp-frappe-sapphire: #85c1dc;
        --ctp-frappe-blue: #8caaee;
        --ctp-frappe-lavender: #babbf1;
        --ctp-frappe-text: #c6d0f5;
        --ctp-frappe-subtext1: #b5bfe2;
        --ctp-frappe-subtext0: #a5adce;
        --ctp-frappe-overlay2: #949cbb;
        --ctp-frappe-overlay1: #838ba7;
        --ctp-frappe-overlay0: #737994;
        --ctp-frappe-surface2: #626880;
        --ctp-frappe-surface1: #51576d;
        --ctp-frappe-surface0: #414559;
        --ctp-frappe-base: #303446;
        --ctp-frappe-mantle: #292c3c;
        --ctp-frappe-crust: #232634;

        /* Terminal colors using Frappe */
        --olivetti: var(--ctp-frappe-green);
        --term-bg: var(--ctp-frappe-base);
        --term-text: var(--ctp-frappe-text);
        --term-border: var(--ctp-frappe-surface2);

        /* Catppuccin Latte theme for README */
        --ctp-latte-rosewater: #dc8a78;
        --ctp-latte-flamingo: #dd7878;
        --ctp-latte-pink: #ea76cb;
        --ctp-latte-mauve: #8839ef;
        --ctp-latte-red: #d20f39;
        --ctp-latte-maroon: #e64553;
        --ctp-latte-peach: #fe640b;
        --ctp-latte-yellow: #df8e1d;
        --ctp-latte-green: #40a02b;
        --ctp-latte-teal: #179299;
        --ctp-latte-sky: #04a5e5;
        --ctp-latte-sapphire: #209fb5;
        --ctp-latte-blue: #1e66f5;
        --ctp-latte-lavender: #7287fd;
        --ctp-latte-text: #4c4f69;
        --ctp-latte-subtext1: #5c5f77;
        --ctp-latte-subtext0: #6c6f85;
        --ctp-latte-overlay2: #7c7f93;
        --ctp-latte-overlay1: #8c8fa1;
        --ctp-latte-overlay0: #9ca0b0;
        --ctp-latte-surface2: #acb0be;
        --ctp-latte-surface1: #bcc0cc;
        --ctp-latte-surface0: #ccd0da;
        --ctp-latte-base: #eff1f5;
        --ctp-latte-mantle: #e6e9ef;
        --ctp-latte-crust: #dce0e8;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--term-bg);
        color: var(--term-text);
        font:
          16px/1.5 ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "DejaVu Sans Mono",
          monospace;
      }
      .layout {
        display: flex;
        height: 100%;
        position: relative;
      }
      .terminal {
        height: 100%;
        padding: 1rem;
        outline: none;
        display: flex;
        flex: 2;
        min-width: 0;
      }
      .screen {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        flex: 1;
        overflow: auto;
        text-shadow:
          0 0 2px currentColor,
          0 0 6px currentColor;
      }
      .readme {
        flex: 1;
        padding: 1rem;
        overflow: auto;
        border-left: 1px solid var(--term-border);
        background: var(--ctp-latte-base);
        color: var(--ctp-latte-text);
        min-width: 0;
      }

      /* Mobile toggle button */
      .mobile-toggle {
        display: none;
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        z-index: 1000;
        background: var(--ctp-frappe-blue);
        color: var(--ctp-frappe-base);
        border: none;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        font-size: 1.5rem;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s;
      }
      .mobile-toggle:active {
        transform: scale(0.95);
      }

      /* Responsive styles */
      @media (max-width: 768px) {
        body {
          font-size: 14px;
        }
        .layout {
          flex-direction: column;
        }
        .terminal {
          flex: 1;
          padding: 0.75rem;
        }
        .readme {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 999;
          border-left: none;
          border-top: 4px solid var(--ctp-frappe-blue);
          transform: translateY(100%);
          transition: transform 0.3s ease;
        }
        .readme.show {
          transform: translateY(0);
        }
        .mobile-toggle {
          display: block;
        }
        .screen {
          text-shadow: none;
        }
      }

      @media (max-width: 480px) {
        body {
          font-size: 12px;
        }
        .terminal {
          padding: 0.5rem;
        }
        .readme {
          padding: 0.75rem;
        }
        .mobile-toggle {
          width: 2.5rem;
          height: 2.5rem;
          font-size: 1.25rem;
        }
      }

      /* Tablet styles */
      @media (min-width: 769px) and (max-width: 1024px) {
        .terminal {
          flex: 1.5;
        }
        .readme {
          flex: 1;
        }
      }

      /* Large desktop */
      @media (min-width: 1440px) {
        body {
          font-size: 18px;
        }
        .layout {
          margin: 0 auto;
        }
      }

      /* Catppuccin Latte styling for documentation content */
      .readme h1,
      .readme h2,
      .readme h3,
      .readme h4,
      .readme h5,
      .readme h6 {
        color: var(--ctp-latte-blue);
        border-bottom: 2px solid var(--ctp-latte-surface1);
        padding-bottom: 0.3em;
      }

      /* Styling for different document types */
      .readme .nfo-content {
        font-family: "Courier New", "DejaVu Sans Mono", monospace;
        font-size: 12px;
        line-height: 1.2;
        color: var(--ctp-latte-text);
        background: var(--ctp-latte-mantle);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        white-space: pre;
        border-left: 4px solid var(--ctp-latte-mauve);
      }

      .readme .text-content {
        color: var(--ctp-latte-text);
        background: var(--ctp-latte-surface0);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        white-space: pre-wrap;
        border-left: 4px solid var(--ctp-latte-green);
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "DejaVu Sans Mono", monospace;
      }

      .readme h1 {
        color: var(--ctp-latte-red);
      }
      .readme h2 {
        color: var(--ctp-latte-peach);
      }
      .readme h3 {
        color: var(--ctp-latte-yellow);
      }
      .readme h4 {
        color: var(--ctp-latte-green);
      }
      .readme h5 {
        color: var(--ctp-latte-teal);
      }
      .readme h6 {
        color: var(--ctp-latte-blue);
      }

      .readme p {
        color: var(--ctp-latte-text);
        line-height: 1.6;
      }

      .readme a {
        color: var(--ctp-latte-sapphire);
        text-decoration: none;
      }

      .readme a:hover {
        color: var(--ctp-latte-blue);
        text-decoration: underline;
      }

      .readme code {
        background: var(--ctp-latte-surface0);
        color: var(--ctp-latte-red);
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 0.9em;
      }

      .readme pre {
        background: var(--ctp-latte-mantle);
        color: var(--ctp-latte-text);
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        border-left: 4px solid var(--ctp-latte-blue);
        line-height: 1;
      }

      .readme pre code {
        background: transparent;
        color: inherit;
        padding: 0;
      }

      .readme blockquote {
        border-left: 4px solid var(--ctp-latte-mauve);
        margin: 0;
        padding-left: 1em;
        color: var(--ctp-latte-subtext0);
        font-style: italic;
      }

      .readme ul,
      .readme ol {
        color: var(--ctp-latte-text);
      }

      .readme li {
        margin: 0.2em 0;
      }

      .readme strong {
        color: var(--ctp-latte-red);
        font-weight: bold;
      }

      .readme em {
        color: var(--ctp-latte-mauve);
        font-style: italic;
      }

      .readme table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
      }

      .readme th,
      .readme td {
        border: 1px solid var(--ctp-latte-surface1);
        padding: 0.5em;
        text-align: left;
      }

      .readme th {
        background: var(--ctp-latte-surface0);
        color: var(--ctp-latte-blue);
        font-weight: bold;
      }

      .readme hr {
        border: none;
        height: 2px;
        background: var(--ctp-latte-surface1);
        margin: 2em 0;
      }

      /* Document type indicator */
      .readme::before {
        content: attr(data-doc-type);
        display: block;
        font-size: 0.8em;
        color: var(--ctp-latte-subtext0);
        text-transform: uppercase;
        margin-bottom: 0.5em;
        padding: 0.2em 0.5em;
        background: var(--ctp-latte-surface1);
        border-radius: 3px;
        width: fit-content;
      }
      .line {
        display: block;
      }
      .ps1 {
        color: var(--ctp-frappe-green);
      }
      .input {
        color: var(--ctp-frappe-text);
      }
      .out {
        color: var(--ctp-frappe-text);
      }
      .out {
        opacity: 0.85;
        line-height: 1.18;
      }
      /* Clickable files/directories */
      .clickable-file {
        cursor: pointer;
        transition: opacity 0.15s ease;
      }
      .clickable-file:hover {
        opacity: 1;
        text-shadow: 0 0 8px currentColor;
      }
      .cursor {
        display: inline-block;
        width: 0.6em;
        background: var(--ctp-frappe-text);
        color: var(--ctp-frappe-base);
      }
      .terminal:focus-within .cursor {
        animation: blink 1s steps(1, end) infinite;
      }
      .terminal:not(:focus-within) .cursor {
        animation: none;
        opacity: 0.5;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }
      ::selection {
        background: var(--ctp-frappe-mauve);
        color: var(--ctp-frappe-base);
      }
      .ghost {
        position: fixed;
        left: -10000px;
        top: auto;
        width: 1px;
        height: 1px;
        opacity: 0;
        border: 0;
        padding: 0;
        background: transparent;
        color: transparent;
      }
    </style>
  </head>
  <body>
    <div
      class="layout"
      data-signals='{ "ps1": "guest@browser:/$ ", "cwd": "/", "current": "", "cursorPos": 0, "buffer": "{{HELP_MESSAGE}}", "history": [], "histIndex": 0, "readme": "", "showReadme": false }'
      data-on-load="
        // Initialize path from URL
        const initialPath = '{{INITIAL_PATH}}';
        if (initialPath && initialPath !== '/') {
          $cwd = initialPath;
          $ps1 = `guest@browser:${initialPath}$ `;
        }

        // Update browser history state
        window.history.replaceState({ cwd: $cwd }, '', $cwd === '/' ? '/' : $cwd);

        // Handle browser back/forward buttons
        window.addEventListener('popstate', (e) => {
          if (e.state && e.state.cwd) {
            $cwd = e.state.cwd;
            $ps1 = `guest@browser:${e.state.cwd}$ `;
            // Fetch readme for the new directory
            fetch('/api/config?path=' + encodeURIComponent(e.state.cwd))
              .then(r => r.json())
              .then(res => {
                if (res && res.readme) {
                  $readme = renderDocument(res.readme, res.docType || 'markdown');
                }
              });
          }
        });
      "
    >
      <div
        class="terminal"
        data-on-load="
            el.querySelector('#ghost').focus();

            // Fetch initial config with path from URL
            const pathFromURL = window.location.pathname;
            fetch('/api/config' + (pathFromURL !== '/' ? '?path=' + encodeURIComponent(pathFromURL) : ''))
              .then(r => r.json())
              .then(res => {
                if (res) {
                  if (res.cwd) {
                    $cwd = res.cwd;
                    $ps1 = `guest@browser:${res.cwd}$ `;
                  }
                  if (res.readme) {
                    $readme = renderDocument(res.readme, res.docType || 'markdown');
                  }
                }

                // Show directory contents on load
                setTimeout(() => {
                  const ghost = document.getElementById('ghost');
                  if (ghost) {
                    ghost.value = 'ls';
                    ghost.dispatchEvent(new Event('input', { bubbles: true }));
                    ghost.value = '';
                    ghost.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));
                  }
                }, 100);
              });

            const init = window.INIT_README || '';
            $readme = init ? renderDocument(init, window.DOC_TYPE) : '';
            window.addEventListener('initreadme', (e) => {
              if (e.detail && typeof e.detail === 'object') {
                $readme = e.detail.content ? renderDocument(e.detail.content, e.detail.type || 'markdown') : '';
              } else {
                // Backward compatibility
                $readme = e.detail ? renderDocument(e.detail, 'markdown') : '';
              }
            });
            window.addEventListener('syncCwd', (e) => {
              if (e.detail && e.detail.cwd) {
                $cwd = e.detail.cwd;
                $ps1 = `guest@browser:${e.detail.cwd}$ `;
              }
            });
          "
        data-on-click="el.querySelector('#ghost').focus()"
        data-on-keydown="
         const k=evt.key;
         if (k==='Enter') {
           const cmd = $current;
           $buffer += `<div class='line'><span class='ps1'>${$ps1}</span>${escapeHTML(cmd)}</div>`;
           if (cmd) { $history.push(cmd); }
           $histIndex = $history.length;
           $current = '';
           $cursorPos = 0;
           const sc = el.querySelector('.screen');
           requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });

           fetch('/api/exec', {
             method: 'POST', headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ input: cmd })
           })
           .then(r => r.ok ? r.json() : Promise.reject(new Error(`HTTP ${r.status}`)))
             .then((res) => {
               const { output, download, cwd, clipboard, html } = res || {};
             if (typeof output === 'string' && output.length) {
               $buffer += `<div class='line out'>${makeClickable(ansiToHtml(output))}</div>`;
             }
             if (html) {
               $buffer += `<div class='line out'>${html}</div>`;
             }
             if (download) { startDownload(download); }
              if (clipboard) {
                // Copy to clipboard
                navigator.clipboard.writeText(clipboard).catch(err => {
                  console.error('Failed to copy to clipboard:', err);
                });
              }
               if (cwd !== undefined) {
                  $cwd = cwd;
                  $ps1 = `guest@browser:${cwd}$ `;
                  // Update URL and browser history when directory changes
                  const newPath = cwd === '/' ? '/' : cwd;
                  if (window.location.pathname !== newPath) {
                    window.history.pushState({ cwd: cwd }, '', newPath);
                  }
               }
               if (res && Object.prototype.hasOwnProperty.call(res, 'readme')) {
                 $readme = res.readme ? renderDocument(res.readme, res.docType || 'markdown') : '';
               }
               requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
           })
           .catch(err => {
             $buffer += `<div class='line out'>error: ${escapeHTML(String(err))}</div>`;
             requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
           });

           evt.preventDefault();
         } else if (k==='Backspace') {
           if ($cursorPos > 0) {
             $current = $current.slice(0, $cursorPos - 1) + $current.slice($cursorPos);
             $cursorPos--;
           }
           evt.preventDefault();
         } else if (k==='Tab') {
           const m = $current.match(/^\s*(\S+)(?:\s+(.*))?$/);
           const cmd = m ? m[1] : '';
           let arg = m && m[2] !== undefined ? m[2] : '';

           // Extract the actual path argument, skipping flags (starting with -)
           let pathArg = '';
           if (arg) {
             const parts = arg.split(/\s+/);
             // Find the last non-flag argument
             for (let i = parts.length - 1; i >= 0; i--) {
               if (parts[i] && !parts[i].startsWith('-')) {
                 pathArg = parts[i];
                 break;
               }
             }
           }

           const isLs = (cmd === 'ls' || cmd === 'dir');
           const isCd = (cmd === 'cd');
           const isCat = (cmd === 'cat');
           const isGet = (cmd === 'wget' || cmd === 'get' || cmd === 'rget' || cmd === 'download');
           const isUrl = (cmd === 'url' || cmd === 'share');
           const isSum = (cmd === 'sum' || cmd === 'checksum');
           if (isLs || isCd || isCat || isGet || isUrl || isSum) {
             const body = { path: pathArg || '', dirsOnly: false, filesOnly: false, maxSize: 0, textOnly: false };
             if (isCd) { body.dirsOnly = true; }
             if (isCat) { body.filesOnly = true; body.textOnly = true; body.maxSize = (window.CAT_MAX||0); }
             if (isGet) { body.filesOnly = true; }
             if (isUrl) { body.filesOnly = true; }
             if (isSum) { body.filesOnly = true; }
             fetch('/api/complete', {
               method: 'POST', headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify(body)
             })
             .then(r => r.ok ? r.json() : Promise.reject(new Error(`HTTP ${r.status}`)))
             .then(({ items }) => {
               if (!Array.isArray(items) || items.length === 0) return;
               const slash = (pathArg||'').lastIndexOf('/');
               const dirPart  = slash >= 0 ? pathArg.slice(0, slash+1) : '';
               const basePart = slash >= 0 ? pathArg.slice(slash+1) : (pathArg||'');
               const names = items.map(it => it.name);
               const lcp = longestCommonPrefix(names);

               // Reconstruct command with flags
               const flagsPart = arg && pathArg ? arg.substring(0, arg.lastIndexOf(pathArg)) : (arg && arg.trim().startsWith('-') ? arg + ' ' : '');

               if (lcp && lcp !== basePart) {
                 $current = cmd + ' ' + flagsPart + (dirPart + lcp);
                 $cursorPos = $current.length; // Fix cursor position
               } else if (items.length === 1) {
                 const one = items[0];
                 $current = cmd + ' ' + flagsPart + (dirPart + one.name + (one.dir ? '/' : ''));
                 $cursorPos = $current.length; // Fix cursor position
               } else {
                 const list = items.map(it => it.name + (it.dir ? '/' : '')).join('  ');
                 $buffer += `<div class='line out'>${makeClickable(ansiToHtml(list))}</div>`;
                 const sc = el.querySelector('.screen'); requestAnimationFrame(()=>{ sc.scrollTop = sc.scrollHeight; });
               }
             })
             .catch(()=>{});
             evt.preventDefault();
           } else {
             $current += '    ';
             evt.preventDefault();
           }
         } else if (k==='ArrowLeft' && evt.ctrlKey) {
           // Ctrl-Left: Move cursor one word left
           const before = $current.slice(0, $cursorPos);
           const match = before.match(/\S*\s*$/);
           if (match) {
             $cursorPos = Math.max(0, $cursorPos - match[0].length);
           }
           evt.preventDefault();
         } else if (k==='ArrowRight' && evt.ctrlKey) {
           // Ctrl-Right: Move cursor one word right
           const after = $current.slice($cursorPos);
           const match = after.match(/^\s*\S*/);
           if (match) {
             $cursorPos = Math.min($current.length, $cursorPos + match[0].length);
           }
           evt.preventDefault();
         } else if (k==='ArrowLeft') {
           // Move cursor left
           if ($cursorPos > 0) {
             $cursorPos--;
           }
           evt.preventDefault();
         } else if (k==='ArrowRight') {
           // Move cursor right
           if ($cursorPos < $current.length) {
             $cursorPos++;
           }
           evt.preventDefault();
         } else if (k==='ArrowUp') {
           if ($histIndex>0) { 
             $histIndex--; 
             $current = $history[$histIndex] ?? ''; 
             $cursorPos = $current.length;
           }
           evt.preventDefault();
         } else if (k==='ArrowDown') {
           if ($histIndex < $history.length) { 
             $histIndex++; 
             $current = $history[$histIndex] ?? ''; 
             $cursorPos = $current.length;
           }
           evt.preventDefault();
         } else if (k==='u' && evt.ctrlKey) {
           // Ctrl-U: Clear the current line (Unix shell behavior)
           $current = '';
           $cursorPos = 0;
           evt.preventDefault();
         } else if (k==='w' && evt.ctrlKey) {
           // Ctrl-W: Delete word backwards (Unix shell behavior)
           const before = $current.slice(0, $cursorPos);
           const after = $current.slice($cursorPos);
           const newBefore = before.replace(/\S*\s*$/, '');
           $current = newBefore + after;
           $cursorPos = newBefore.length;
           evt.preventDefault();
         } else if (k==='k' && evt.ctrlKey) {
           // Ctrl-K: Delete from cursor to end of line (Unix shell behavior)
           $current = $current.slice(0, $cursorPos);
           evt.preventDefault();
         } else if (k==='l' && evt.ctrlKey) {
           // Ctrl-L: Clear screen (Unix shell behavior)
           $buffer = '';
           evt.preventDefault();
         } else if (k==='a' && evt.ctrlKey) {
           // Ctrl-A: Move cursor to beginning of line
           $cursorPos = 0;
           evt.preventDefault();
         } else if (k==='e' && evt.ctrlKey) {
           // Ctrl-E: Move cursor to end of line  
           $cursorPos = $current.length;
           evt.preventDefault();
         }
       "
      >
        <input
          id="ghost"
          class="ghost"
          type="text"
          inputmode="text"
          autocomplete="off"
          autocapitalize="off"
          spellcheck="false"
          autofocus
          aria-label="Hidden terminal input"
          data-on-input="
            const val = evt.target.value;
            if (val && val.charCodeAt(0) > 31) {
              $current = $current.slice(0, $cursorPos) + val + $current.slice($cursorPos);
              $cursorPos += val.length;
            }
            evt.target.value = '';
          "
        />

        <pre
          id="screen"
          class="screen"
          data-ref-screen
          data-effect="
            const before = $current.slice(0, $cursorPos);
            const cursorChar = $current[$cursorPos] || ' ';
            const after = $current.slice($cursorPos + 1);
            el.innerHTML = $buffer + `<div class='line'><span class='ps1'>${$ps1}</span><span class='input-before'></span><span class='cursor'></span><span class='input-after'></span></div>`;
            el.querySelector('.input-before').textContent = before;
            el.querySelector('.cursor').textContent = cursorChar;
            el.querySelector('.input-after').textContent = after;
          "
        ></pre>
      </div>
      <div
        id="readme"
        class="readme"
        data-class-show="$showReadme"
        data-effect="el.innerHTML = $readme"
      ></div>
      <button
        class="mobile-toggle"
        data-on-click="$showReadme = !$showReadme"
        data-text="$showReadme ? 'âœ•' : 'ðŸ“–'"
        aria-label="Toggle README"
      ></button>
    </div>
  </body>
</html>
